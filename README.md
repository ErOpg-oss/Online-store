                    Система интернет-магазина

3.1 Описание задачи

Цель работы
Разработать консольное приложение для управления интернет-магазином, демонстрирующее применение принципов объектно-ориентированного программирования, работу с базами данных PostgreSQL и использование современных возможностей языка C++ (умные указатели, шаблоны, алгоритмы STL).

Краткое описание реализованной системы интернет-магазина
Система представляет собой консольное приложение для управления интернет-магазином с поддержкой трех ролей пользователей:
- Администратор - полный контроль над системой, управление товарами, пользователями, заказами
- Менеджер - обработка и сопровождение заказов, управление складом
- Покупатель - создание и оплата заказов, отслеживание статусов

Система обеспечивает полный цикл работы с заказами, включая создание, оплату, возврат и отмену. Все действия пользователей автоматически фиксируются в системе аудита, а изменения статусов заказов сохраняются в истории.

Используемые технологии
- C++17 - основной язык разработки с поддержкой умных указателей и лямбда-выражений
- PostgreSQL - реляционная СУБД для хранения данных
- libpqxx - C++ библиотека для работы с PostgreSQL
- OpenSSL - криптографические функции для хеширования паролей
- CMake - система сборки проекта


3.2 Архитектура проекта

Описание классов и их взаимосвязей
Система построена на основе объектно-ориентированной архитектуры:

- Базовый класс User - абстрактный класс с чисто виртуальными методами
- Производные классы:
  - Admin - администратор системы
  - Manager - менеджер заказов
  - Customer - покупатель

- Класс Order - управление заказами
- Класс OrderItem - элементы заказа (композиция с Order)
- Класс PaymentStrategy - абстрактный класс для стратегий оплаты
- Конкретные стратегии оплаты:
  - CardPayment - оплата банковской картой
  - WalletPayment - оплата электронным кошельком
  - SBPPayment - оплата через СБП

- Класс DatabaseConnection<T> - шаблонный класс для работы с БД
- Класс Menu - управление пользовательским интерфейсом
- Класс Authentication - аутентификация и регистрация пользователей

Применение принципов ООП

Наследование:
```cpp
class User { ... };
class Admin : public User {  ... };
class Manager : public User {  ... };
class Customer : public User { ... };
```

Полиморфизм:
- Виртуальные методы displayInfo(), createOrder(), cancelOrder()
- Динамическое связывание через указатели на базовый класс

Композиция:
- Класс Order содержит объекты OrderItem
- Объекты OrderItem не могут существовать отдельно от Order

Агрегация:
- Класс User хранит коллекцию std::shared_ptr<Order>
- Заказы могут существовать независимо от пользователей (в БД)

Использование шаблонного класса DatabaseConnection<T>
Шаблонный класс DatabaseConnection<T> обеспечивает типобезопасную работу с PostgreSQL:
- Поддерживает различные типы данных через параметр шаблона T
- Предоставляет методы для выполнения запросов и управления транзакциями
- Обеспечивает автоматическое освобождение ресурсов через умные указатели



3.3 Работа с базой данных

Описание структуры базы данных
База данных состоит из 6 взаимосвязанных таблиц, нормализованных до 3НФ:

Список таблиц
1. users - пользователи системы (администраторы, менеджеры, покупатели)
2. products - каталог товаров магазина
3. orders - основные данные заказов
4. order_items - состав заказов (товары и их количество)
5. order_status_history - история изменения статусов заказов
6. audit_log - журнал аудита всех действий пользователей

Описание хранимых процедур, функций и триггеров

Хранимые процедуры:
- create_order_simple() - создание нового заказа с проверкой наличия товара
- update_order_status_simple() - безопасное изменение статуса заказа
- pay_order_simple() - обработка оплаты заказа
- return_order_simple() - обработка возврата заказа

Функции:
- get_order_status() - получение текущего статуса заказа
- can_return_order() - проверка возможности возврата заказа
- generate_csv_report() - генерация отчета в формате CSV
- get_audit_log_by_user() - получение журнала аудита по пользователю

Триггеры:
- audit_orders_trigger - автоматическое логирование операций с заказами
- order_status_history_trigger - автоматическое ведение истории статусов
- audit_products_trigger - логирование операций с товарами
- audit_users_trigger - логирование операций с пользователями

Механизм транзакций и отката при ошибках
Все критические операции выполняются в рамках транзакций:
```cpp
db.beginTransaction();
try {
    // Выполнение операций
    db.executeNonQuery("UPDATE products SET stock = stock - 1");
    db.executeNonQuery("INSERT INTO orders (...) VALUES (...)");
    db.commitTransaction();
} catch (...) {
    db.rollbackTransaction();
    // Запись об ошибке в audit_log
}
```

3.4 Умные указатели и STL

Где и почему используются std::unique_ptr и std::shared_ptr

std::unique_ptr:
- Для стратегий оплаты в классе Order: std::unique_ptr<PaymentStrategy> payment
- Для объектов, которые должны иметь единственного владельца
- Обеспечивает автоматическое освобождение памяти при выходе из области видимости

std::shared_ptr:
- Для хранения заказов пользователей: std::vector<std::shared_ptr<Order>> orders
- Когда несколько объектов должны совместно владеть ресурсом
- Счетчик ссылок обеспечивает автоматическое удаление, когда последний владелец освобождает ресурс

Примеры использования STL алгоритмов и лямбда-выражений

std::find_if - поиск заказа по ID:
```cpp
auto it = std::find_if(orders.begin(), orders.end(),
    [orderId](const std::shared_ptr<Order>& order) {
        return order->getId() == orderId;
    });
```

std::copy_if - фильтрация заказов по статусу:
```cpp
std::vector<std::shared_ptr<Order>> pendingOrders;
std::copy_if(orders.begin(), orders.end(), 
             std::back_inserter(pendingOrders),
             [](const std::shared_ptr<Order>& order) {
                 return order->getStatus() == "pending";
             });
```

std::accumulate - подсчет общей суммы заказов:
```cpp
double totalSpent = std::accumulate(orders.begin(), orders.end(), 0.0,
    [](double sum, const std::shared_ptr<Order>& order) {
        return sum + order->total();
    });
```

Лямбда-выражения - проверка прав доступа:
```cpp
auto checkPermission = [](const std::string& role, const std::string& action) -> bool {
    if (role != "admin") return false;
    static const std::vector<std::string> adminActions = {
        "add_product", "update_product", "delete_product",
        "view_all_orders", "update_order_status", "view_audit"
    };
    return std::find(adminActions.begin(), adminActions.end(), action) != adminActions.end();
};
```

3.5 Логика ролей и прав доступа

Возможности администратора, менеджера и покупателя

Администратор (Admin):
- Полный контроль над системой
- Управление каталогом товаров (добавление, обновление, удаление)
- Просмотр всех заказов и их состава
- Изменение статусов любых заказов
- Просмотр истории изменения статусов заказов
- Просмотр журнала аудита действий всех пользователей
- Генерация CSV-отчетов

Менеджер (Manager):
- Утверждение заказов покупателей
- Обновление информации о товарах на складе (количество)
- Просмотр заказов, находящихся в обработке (статус "pending")
- Изменение статусов заказов в рамках своих полномочий
- Просмотр истории заказов, которые были утверждены данным менеджером
- Доступ только к данным аудита, относящимся к операциям с заказами

Покупатель (Customer):
- Создание новых заказов
- Добавление и удаление товаров из своих заказов
- Просмотр списка своих заказов и их текущих статусов
- Оплата заказов с использованием выбранной стратегии оплаты:
  - Банковская карта
  - Электронный кошелёк
  - Система быстрых платежей (СБП)
- Оформление возврата заказа при соблюдении бизнес-правил:
  - Заказ завершён (статус "completed")
  - Прошло не более 30 дней с момента оформления
- Доступ только к своим заказам, без доступа к журналу аудита

Ограничения доступа к истории заказов и журналу аудита

- Администратор: полный доступ ко всей истории и журналу аудита
- Менеджер: доступ только к истории заказов и аудиту операций с заказами
- Покупатель: доступ только к истории своих заказов, без доступа к аудиту

Реализация проверки прав доступа
Проверка прав реализована через метод `hasPermission()` в каждом классе пользователя:
```cpp
bool Admin::hasPermission(const std::string& action) const {
  ...
}
```



3.6 Аудит и история изменений

Описание таблиц order_status_history и audit_log

Таблица order_status_history:
- history_id - уникальный идентификатор записи истории
- order_id - идентификатор заказа (внешний ключ)
- old_status - предыдущий статус заказа
- new_status - новый статус заказа
- changed_at - дата и время изменения
- changed_by - пользователь, изменивший статус (внешний ключ)

Таблица audit_log:
- log_id - уникальный идентификатор записи аудита
- entity_type - тип сущности ('order', 'product', 'user')
- entity_id - идентификатор сущности
- operation - тип операции ('insert', 'update', 'delete')
- performed_by - пользователь, выполнивший операцию (внешний ключ)
- performed_at - дата и время операции

Механизм автоматического логирования
Логирование реализовано через триггеры PostgreSQL:
- Триггеры срабатывают автоматически при операциях INSERT, UPDATE, DELETE
- Записывают информацию в таблицы audit_log и order_status_history
- Используют системную переменную app.user_id для идентификации пользователя

Примеры записей аудита

История изменения статуса заказа:
```
1001     | pending    | completed  | 2 (Manager)| 2024-01-15 14:30:00
1001     | completed  | returned   | 3 (Customer)| 2024-01-20 10:15:00
```

Запись в журнале аудита:
```
product     | 45        | update    | 1 (Admin)    | 2024-01-10 09:45:00
order       | 1001      | update    | 2 (Manager)  | 2024-01-15 14:30:00
user        | 5         | insert    | 1 (Admin)    | 2024-01-05 11:20:00
```



3.7 Отчёт в формате CSV

Описание отчёта «История изменений заказов и действий пользователей»
Отчет объединяет данные из трех таблиц:
- orders - основная информация о заказах
- order_status_history - история изменения статусов
- audit_log - журнал аудита действий

Отчет предназначен для администраторов и предоставляет полную картину всех изменений в системе.

SQL-запрос или функция, формирующая отчёт
```sql
CREATE OR REPLACE FUNCTION generate_csv_report()
RETURNS TEXT AS $$
DECLARE
    csv_content TEXT;
BEGIN
    SELECT string_agg(
        o.order_id || ',' ||
        COALESCE(u.name, '') || ',' ||
        COALESCE(o.status, '') || ',' ||
        COALESCE(o.total_price::TEXT, '0') || ',' ||
        COALESCE(o.order_date::TEXT, '') || ',' ||
        COALESCE(osh.old_status, '') || ',' ||
        COALESCE(osh.new_status, '') || ',' ||
        COALESCE(osh.changed_at::TEXT, '') || ',' ||
        COALESCE(al.operation, '') || ',' ||
        COALESCE(u2.name, '') || ',' ||
        COALESCE(al.performed_at::TEXT, ''),
        E'\n'
    ) INTO csv_content
    FROM orders o
    LEFT JOIN users u ON o.user_id = u.user_id
    LEFT JOIN order_status_history osh ON o.order_id = osh.order_id
    LEFT JOIN audit_log al ON o.order_id = al.entity_id AND al.entity_type = 'order'
    LEFT JOIN users u2 ON al.performed_by = u2.user_id
    ORDER BY o.order_date DESC;
    
    RETURN 'order_id,user_name,status,total_price,order_date,old_status,new_status,changed_at,operation,performed_by_name,performed_at' || 
           E'\n' || 
           COALESCE(csv_content, '');
END;
$$ LANGUAGE plpgsql;
```

Пример содержимого CSV-файла
```csv
order_id,user_name,status,total_price,order_date,old_status,new_status,changed_at,operation,performed_by_name,performed_at
1001,Иван Иванов,completed,15000.50,2024-01-10 10:30:00,pending,completed,2024-01-10 11:00:00,update,Петр Петров,2024-01-10 11:00:00
1001,Иван Иванов,returned,15000.50,2024-01-10 10:30:00,completed,returned,2024-01-12 14:20:00,update,Иван Иванов,2024-01-12 14:20:00
1002,Мария Сидорова,pending,8500.00,2024-01-11 09:15:00,NULL,pending,2024-01-11 09:15:00,insert,Мария Сидорова,2024-01-11 09:15:00
```



3.8 Сборка и запуск проекта

Требования к окружению
- Компилятор C++ с поддержкой стандарта C++17 (g++ 7+, clang 5+)
- PostgreSQL версии 14 или выше
- Библиотека libpqxx версии 7.0 или выше
- Библиотека OpenSSL для хеширования паролей
- CMake версии 3.10 или выше

Инструкции по сборке
1. Клонируйте репозиторий:
```bash
git clone git@github.com:ErOpg-oss/Online_Store.git
cd online-store
```

1. Создайте и настройте базу данных:
```bash
 Создание базы данных
createdb online-store

 Выполнение SQL-скриптов в правильном порядке
psql -d online-store -f sql/tables.sql
psql -d online-store -f sql/functions.sql
psql -d online-store -f sql/procedures.sql
psql -d online-store -f sql/triggers.sql
psql -d online-store -f sql/insertdata.sql 
```

3. Соберите проект:
```bash
mkdir build && cd build
cmake ..
make
```

Инструкция по запуску программы
```bash
./online-store
```

Пример запуска программы
```
$ ./online-store

=== ГЛАВНОЕ МЕНЮ ===
1. Войти как администратор
2. Войти как менеджер
3. Войти как покупатель
4. Регистрация
5. Выход
> 
```

Примеры работы меню для разных ролей

Меню администратора:
```
=== МЕНЮ АДМИНИСТРАТОРА ===
1. Добавить продукт
2. Обновить продукт
3. Удалить продукт
4. Просмотр всех заказов
5. Детали заказа
6. Изменить статус заказа
7. История статусов заказа
8. Отменить заказ
9. Журнал аудита
10. CSV-отчёт
11. Выход
> 
```

Меню менеджера:
```
=== МЕНЮ МЕНЕДЖЕРА ===
1. Заказы на утверждение (pending)
2. Утвердить заказ
3. Обновить склад
4. Детали заказа
5. Изменить статус заказа
6. Отменить заказ
7. История утверждённых заказов
8. Выход
> 
```

Меню покупателя:
```
=== МЕНЮ ПОКУПАТЕЛЯ ===
1. Создать заказ
2. Добавить товар в заказ
3. Удалить товар из заказа
4. Мои заказы
5. Статус заказа
6. Оплатить заказ
7. Отменить заказ
8. Возврат заказа
9. История статусов
10. Выход
> 
```
Пример меню регистрации
```
РЕГИСТРАЦИЯ
Имя: 
Email: 
Пароль: 
Роль (admin/manager/customer): 
```

Пример записи в журнале аудита:
```
Аудит пользователя 1 (Администратор):
order 1001: update (пользователь: Администратор, время: 2024-01-10 09:00:00)
product 45: update (пользователь: Администратор, время: 2024-01-09 14:30:00)
user 5: insert (пользователь: Администратор, время: 2024-01-08 10:15:00)
```